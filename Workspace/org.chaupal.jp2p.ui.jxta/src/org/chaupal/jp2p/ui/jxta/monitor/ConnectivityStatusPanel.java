/*******************************************************************************
 * Copyright (c) 2014 Chaupal.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution, and is available at
 * http://www.apache.org/licenses/LICENSE-2.0.html
 *******************************************************************************/

package org.chaupal.jp2p.ui.jxta.monitor;

import java.util.Collections;
import java.util.List;
import javax.swing.JPanel;
import javax.swing.table.DefaultTableModel;

/**
 * This frame collects and displays connectivity information from a peergroup.
 */
public class ConnectivityStatusPanel extends JPanel {

    // Static

    /**
	 * 
	 */
	private static final long serialVersionUID = 1L;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable LocalEdgeTable;
    private javax.swing.JTable LocalRDVTable;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables


    private DefaultTableModel LocalRDVs_TM = null;
    private String[] LocalRDV_Col = { "Local RDV View IDs" };

    private DefaultTableModel LocalEdges_TM = null;
    private String[] LocalEdge_Col = { "Local EDGE View IDs" };

    private static final String[][] EmptyTableContent = new String[0][1];

    /** Creates new form ConnectivityMonitor */
    public ConnectivityStatusPanel() {
        initComponents();

        // Setting own default table models
        LocalRDVs_TM = new DefaultTableModel(EmptyTableContent, LocalRDV_Col);
        this.LocalRDVTable.setModel(LocalRDVs_TM);

        LocalEdges_TM = new DefaultTableModel(EmptyTableContent, LocalEdge_Col);
        this.LocalEdgeTable.setModel(LocalEdges_TM);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        LocalEdgeTable = new javax.swing.JTable();
        jScrollPane2 = new javax.swing.JScrollPane();
        LocalRDVTable = new javax.swing.JTable();

        javax.swing.GroupLayout StatusPaneLayout = new javax.swing.GroupLayout(this);
        this.setLayout(StatusPaneLayout);
        StatusPaneLayout.setHorizontalGroup(
            StatusPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, StatusPaneLayout.createSequentialGroup()
                .addContainerGap()
        ));
        StatusPaneLayout.setVerticalGroup(
            StatusPaneLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(StatusPaneLayout.createSequentialGroup()
                .addContainerGap()
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGap(18, 18, 18)
        ));

        LocalEdgeTable.setFont(new java.awt.Font("Tahoma", 0, 9));
        LocalEdgeTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null}
            },
            new String [] {
                "Local Edge View IDs"
            }
        ) {
            /**
			 * 
			 */
			private static final long serialVersionUID = 1L;
			Class<?>[] types = new Class [] {
                java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false
            };

            @Override
			public Class<?> getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            @Override
			public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        LocalEdgeTable.getColumnModel().getColumn(0).setResizable(false);
        LocalRDVTable.setFont(new java.awt.Font("Tahoma", 0, 9));
        LocalRDVTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null}
            },
            new String [] {
                "Local RDV View IDs"
            }
        ) {
            /**
			 * 
			 */
			private static final long serialVersionUID = 1L;
			Class<?>[] types = new Class [] {
                java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false
            };

            @Override
			public Class<?> getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            @Override
			public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane2.setViewportView(LocalRDVTable);
        LocalRDVTable.getColumnModel().getColumn(0).setResizable(false);
    }// </editor-fold>//GEN-END:initComponents

    void updateRDVs( List<String> inNewContent ){
    	this.updateTableContent(LocalRDVs_TM, inNewContent, LocalRDV_Col );
    }

    void updateEdges( List<String> inNewContent ){
    	this.updateTableContent(LocalEdges_TM, inNewContent, LocalEdge_Col );
    }

    private void updateTableContent(DefaultTableModel inTM, List<String> inNewContent, String[] inColumns) {
        // Do we have the same number of elements
        if ( inTM.getRowCount() == inNewContent.size() ) {
            // Sorting new candidates
            Collections.sort(inNewContent);

            // Replacing items that have to be replaced
            for (int i=0;i<inNewContent.size();i++) {
                if ( inNewContent.get(i).compareTo((String) inTM.getValueAt(i, 0)) != 0 )
                    inTM.setValueAt(inNewContent.get(i), i, 0);
            }
            // Done
            return;
        }

        // We need a new data vector
        String[][] NewContent = new String[inNewContent.size()][1];
        for (int i=0;i<inNewContent.size();i++) NewContent[i][0] = inNewContent.get(i);
        inTM.setDataVector(NewContent, inColumns);
    }
}
